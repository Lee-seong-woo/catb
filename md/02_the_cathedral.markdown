# 2장 성당과 시장

정직한 역[^2-1]

[^2-1]: 역자주 이 글은 [1998년 5월 13일에 공개된 정직한 씨](https://web.archive.org/web/20000311184834/http://kldp.org/Webroot/cathedral-bazaar/cathedral-bazaar.html)의 번역을 송창훈이 보충한 것이다. 이 글은 정직한 씨의 번역에 (1) 후기를 포함한 개정 내용 일부를 반영하고, (2) 참고할 만한 자료를 역자주로 추가하고, (3) 책의 전체적인 일관성을 맞추기 위해 용어와 외래어 표기, 표현 등을 통일하는 작업 외에는 가능한 원래의 번역을 수정하지 않으려고 노력했다. 만약 원문이나 원번역과의 차이로 인한 오류가 있다면, 이는 전적으로 나중 역자의 책임이다. 이 글의 원문은 <http://www.catb.org/~esr/writings/cathedral-bazaar/cathedralbazaar/>에서 볼 수 있으며, 번역에 사용한 판본은 1998년 11월 20일에 개정된 1.44판이다. 한국어 번역문의 최종 개정일은 2013년 12월 23일이다.

## 요약

이 글은 성공적인 오픈소스 프로젝트인 페치메일`fetchmail`을 분석한다. 이 프로젝트는 리눅스의 역사가 제시한 놀라운 소프트웨어 공학 이론을 신중히 검토해 보려고 진행한 것이다. 이 이론을 두 개의 근본적으로 다른 개발 방식의 용어로 논할 것이다. 두 가지 방식이란 상업용 소프트웨어의 ‘성당’ 모델과 리눅스 세계의 ‘시장’ 모델이다. 이 모델들은 소프트웨어 디버깅 작업의 본질에 대한 서로 대립하는 가설들로부터 파생됐다는 것을 보일 것이다. 그 뒤에 리눅스의 경험으로부터 ‘충분히 많은 사람이 있다면, 찾을 수 없는 버그란 없다’는 일관된 주장을 펴고, 이기적 에이전트의 자가수정 시스템과 생산적인 비유를 해 본 다음, 마지막으로 소프트웨어의 미래를 위해 이 통찰이 가지는 의미에 대해 탐구해 보려고 한다.[^2-2]

[^2-2]: 역자주 이 글의 내용에 대한 첫 번째 대중 강연은 1997년 5월 바이에른(Bavaria)에서 열린 리눅스 회의(Linux Kongress)에서 행해졌다. 강연 내용은 <http://www.catb.org/~esr/writings/cathedral-bazaar/linux1_d50_96kbs.mp3>에서 오디오 자료로 참고할 수 있다.

## 성당과 시장

리눅스는 파괴적이다. 파트타임으로 해킹하면서 인터넷이라는 가느다란 선만으로 연결된 전 세계 수천 명의 개발자에 의해 세계적인 수준의 운영체제가 마치 마술처럼 만들어질 수 있었으리라고 5년 전에 누가 감히 상상이나 할 수 있었을까?

나는 분명 상상하지 못했다. 1993년 초 리눅스가 내 레이더 화면에 잡혔을 때, 나는 이미 10년 동안 유닉스와 오픈소스 개발을 해오고 있었으며 1980년대 중반에 GNU에 공헌한 첫 번째 사람들 중 한 명이었다. 나는 네트워크에 꽤 많은 오픈소스 소프트웨어를 발표했고, 지금도 널리 사용되는 [네트핵](http://www.nethack.org/)과 이맥스 VC 모드, GUD 모드, [xlife](http://litwr2.atspace.eu/xlife.php)[^2-3] 등 몇몇 프로그램을 개발 중이거나 공동 개발하고 있었다. 나는 프로그램이 어떻게 개발돼야 하는지 알고 있다고 생각했다.

[^2-3]: 역자주 라이프는 영국의 수학자 존 콘웨이(John Conway)가 개발한 컴퓨터 시뮬레이션 게임으로 『해커, 그 광기와 비밀의 기록, 사민서각, 김동광 옮김, 1996년, ISBN: 9788986311341』의 제1부 7장(190페이지) ‘LIFE’ 부분에서도 자세한 내용을 참고할 수 있다. 이맥스의 모드(mode)는 여러 형태의 작업을 할 수 있는 개별 작업 상태를 말하는 것으로 사용자가 리스프 언어로 직접 만들어 추가기능(add-in)이나 확장기능(Extension)처럼 쓸 수 있다. [VC(Version Control) 모드](http://korea.gnu.org/people/chsong/cb/homesteading/vc.el)와 [GUD(Grand Unified Debugger) 모드](http://korea.gnu.org/people/chsong/cb/homesteading/gud.el)는 소스 코드 판(version) 관리와 디버깅에 사용되는 것이다.

리눅스는 내가 알고 있다고 생각한 많은 부분을 뒤집어 버렸다. 나는 작은 도구, 빠른 원형 제작`prototyping`, 그리고 진화적인 프로그래밍을 여러 해 동안 유닉스의 복음으로 설교하고 있었다. 하지만 나는 어떤 종류의 매우 중요한 복잡성이 있기 때문에, 거기에는 더 집중되고 선험적인 접근 방법이 필요하다고 믿고 있었다. 운영체제나 이맥스 등 대단히 커다란 도구같이 가장 중요한 소프트웨어는 성당을 건축하듯이, 즉 찬란한 고독 속에서 일하는 몇 명의 도사 프로그래머나 작은 모임의 뛰어난 프로그래머에 의해서 조심스럽게 만들어지고, 때가 되기 전에 발표되는 베타판도 없어야 한다고 생각했던 것이다.

일찍, 그리고 자주 발표하며 다른 사람에게 위임할 수 있는 것은 모두 위임하고, 뒤범벅된 부분까지 공개하는 그런 리누스 토르발스`Linus Torvalds`의 개발 방식은 나에게 놀라움으로 다가왔다. 고요하고 신성한 성당의 건축 방식은 여기에서 찾아볼 수 없었다. 대신 리눅스 공동체는 서로 다른 의견과 접근 방법이 난무하는 매우 소란스러운 시장 같았다. (공공 자료 보관소인 리눅스 아카이브 사이트가 이것을 적절히 상징하고 있다. 이곳에는 누구나 파일을 올릴 수 있다.) 이런 시장 바닥에서 조리 있고 안정적인 소프트웨어가 나온다는 것은 거듭되는 기적에 의해서만 가능한 것처럼 보였다.

시장 방식이 매우 효과적이라는 사실은 분명 충격이었다. 리눅스 공동체에 익숙해져 가면서 나는 개개의 프로젝트에 열중했을 뿐 아니라 왜 리눅스 세계가 공중분해 되지 않고 성당 건축가들이 상상하기도 힘든 속도로 계속해서 강해지는지 이해하려고 애썼다.

1996년 중반에야 이해가 되기 시작했다. 내 이론을 시험해 볼 완벽한 기회가 오픈소스 프로젝트의 형태로 찾아왔다. 여기에서 나는 의식적으로 시장 방식을 시도해 볼 수 있었고, 큰 성공을 거두었다.

이제부터 그 프로젝트에 대해 이야기하고 효과적인 오픈소스 개발에 대한 격언들을 제시할 것이다. 내가 이 모든 것을 리눅스 세계에서 처음 배운 것은 아니지만, 리눅스 세계는 이 격언들이 특별한 의미를 가질 수 있게 해주었다. 만일 내가 옳다면, 독자들은 이 격언들로부터 리눅스 공동체가 훌륭한 소프트웨어를 만들어내는 원천이 될 수 있었던 이유를 이해할 수 있을 것이며, 독자들 자신도 더 생산적이 되는 데 도움을 받을 수 있을 것이다.

## 메일은 배달되어야만 한다

나는 1993년에 펜실베이니아주 웨스트체스터`West Chester, Pennsylvania`에 있는 자그마한 무료 인터넷 서비스 제공업체`ISP: Internet Service Provider`인 체스터 카운티 인터링크`CCIL: Chester County InterLink`에서 기술 업무를 담당하고 있었다. (나는 CCIL을 공동 설립했고, 우리만의 다중 사용자`multiuser` BBS`Bulletin Board System`를 만들었다. 텔넷으로 locke.ccil.org에 접속하면 볼 수 있으며 지금은 19회선에 3,000여 명의 사용자를 지원한다.) 이 일 덕분에 나는 하루 24시간 내내 CCIL의 56K 회선을 통해 네트워크에 접속할 수 있었다.  사실 그렇게 해야만 하는 상황이었다.

그래서 나는 바로바로 배달되는 인터넷 이메일에 매우 익숙해져 있었다. 하지만 몇가지 복잡한 이유 때문에 이름이 ‘snark.thyrsus.com’인 내 집의 컴퓨터와 CCIL간의 SLIP`Serial Line Internet Protocol` 연결이 꽤 힘들었다. 마침내 성공했을 때는 주기적으로 locke에 접속해 메일이 왔는지 확인해 보는 것이 매우 귀찮은 일이라는 것을 알게 됐다. 내가 원한 것은 메일이 locke에서 snark로 배달되고, 도착 즉시 알 수 있으며, 또한 내 컴퓨터 도구를 이용해 메일을 다루는 것이었다.

센드메일`Sendmail`을 이용해 단순히 포워딩하는 것은 소용이 없었다. 내 개인 컴퓨터가 항상 네트워크에 연결된 것도 아니고 고정 IP 주소가 있지도 않았다. SLIP 연결이 되면 메일을 가져와 내 컴퓨터로 배달해주는 프로그램이 필요했다. 그런 프로그램이 몇 개 있었지만, 대부분 POP`Post Office Protocol`을 프로토콜로 사용했다. 물론 locke의 BSD 운영체제에는 POP3 서버가 포함돼 있었다.

하지만 내게 필요한 것은 POP3 클라이언트였다. 그래서 네트워크를 뒤져 하나를 찾아냈다. 사실 서너 개를 찾아내긴 했다. 잠시 pop-perl을 사용했지만, 기본적인 기능이 빠져 있었다. 가져온 메일에서 발신자 주소를 제대로 처리하지 못해서 답장을 보낼 수 없었던 것이다.

문제는 이런 것이었다. locke의 사용자 중에 ‘joe’라는 사람이 내게 메일을 보냈다고 해보자. snark로 메일을 가져와서 그 메일에 답장하려고 하면, 메일 프로그램은 snark에는 있지도 않은 ‘joe’에게 답장을 보내려고 시도한다. 그래서 직접 ‘@ccil.org’를 답장받을 사람의 주소 뒤에 써 붙여야 했는데, 이것은 곧 매우 피곤한 일이 돼버렸다.

이런 일은 분명 컴퓨터가 해줘야 되는 일이었다. 하지만 기존의 POP 클라이언트 중에서 어느 것도 이 일을 해주지 못했다. 여기서 첫 번째 교훈을 얻을 수 있다.

 1. 모든 좋은 소프트웨어는 개발자 개인의 가려운 곳을 긁는 것으로부터 시작된다.

명확해 보이는 교훈이긴 하지만 ‘필요는 발명의 어머니’라는 오래된 속담이 있지 않은가? 소프트웨어 개발자들은 너무나 자주, 단지 돈 때문에 그들이 필요하지도 않고 좋아하지도 않는 프로그램을 만드는 데 시간을 쓰고 있다. 하지만 리눅스 세계에서는 그렇지 않다. 아마도 이것이 리눅스 공동체에서 만들어진 소프트웨어의 평균적 품질이 왜 그렇게나 좋은지 설명해 줄 것이다.

그래서 내가 이미 있는 POP3 클라이언트들과 경쟁하는 새로운 프로그램을 곧바로 코딩하기 시작했을까? 천만에. 나는 이미 가지고 있는 POP 유틸리티들을 조심스럽게 살피며 자신에게 물었다. ‘내가 원하는 것과 가장 가까운 프로그램은 어느 것일까?’

 2. 좋은 프로그래머는 어떤 프로그램을 만들어야 할지 안다. 위대한 프로그래머는 어떤 프로그램을 다시 만들어야 할 지 그리고 재사용해야 할지 안다.

내가 위대한 프로그래머라는 말은 아니지만 흉내 내려고는 했다. 위대한 프로그래머의 중요한 특징 중 하나는 건설적인 게으름이다.[^2-4] 그들은 들인 노력으로가 아니라 결과로 평가받는다는 것을 알고 있으며, 완전한 무에서 시작하는 것보다는 부분적으로나마 좋은 해결책에서 시작하는 게 대부분 더 쉽다는 것을 알고 있다.

[^2-4]: 역자주 <[역자주 8](/fn-2-8/)> 참고.

[리누스 토르발스](https://web.archive.org/web/19990911182554/http:/www.tuxedo.org/~esr/faqs/linus/)를 예로 들자면 그는 맨바닥에서 리눅스`Linux: LINUs’s uniX`를 만들려고 하지 않았다. 그는 대신 386 컴퓨터를 위한 유닉스`Unix: UNiplexed Information and Computing Service`와 비슷한 소형 운영체제 미닉스`Minix: MINImal uniX`의 코드와 아이디어를 재사용하는 것으로부터 시작했다. 결국, 모든 미닉스 코드는 사라지거나 새로 쓰였다. 하지만 미닉스 코드가 남아있는 동안 그 코드는 나중에 리눅스가 될 어린 아기의 발판 역할을 했다.

똑같은 생각으로 나는 이미 있는 POP 유틸리티 중 코딩이 잘된 것을 찾아 개발의 기초로 사용하려고 했다.

소스 공유에 대한 유닉스 세계의 전통은 언제나 코드 재사용에 호의적이었다. GNU 프로젝트가 유닉스 자체에 대한 심각한 의혹에도 불구하고 유닉스를 기본 OS로 선택한 것도 바로 이런 이유에서였다. 리눅스 세계는 거의 기술적인 한계에 다다를 때까지 이 전통을 받아들였다. 일반적으로 찾아볼 수 있는 공개된 소스는 수 테라바이트에 달했다. 그래서 리눅스 세계에서는 누군가가 만든 거의 완성된 소스를 찾아보는데 시간을 들이는 것이 다른 어느 곳에서보다 좋은 결과를 가져올 가능성이 높다.

나 역시 그랬다. 예전에 찾아놓은 것에다 두 번째 검색 결과를 더하니 모두 아홉 개의 후보가 생겼다. fetchpop, PopTart, get-mail, gwpop, pimp, pop-perl, popc, popmail 그리고 upop이었다.[^2-5] 가장 먼저 정착한 프로그램은 오승홍 씨의 fetchpop이었다. 나는 헤더 재작성 기능과 더불어 몇몇 개선 사항을 추가했고, 저자는 릴리스 1.9에 그것을 수용했다.

[^2-5]: 역자주 <http://www.ibiblio.org/pub/Linux/system/mail/pop/> 참고.

몇 주 후, 나는 칼 해리스`Carl Harris`가 만든 팝클라이언트popclient의 코드를 들여다보다가 문제점을 발견했다. Fetchpop에는 백그라운드 데몬 모드 같은 훌륭한 독창적인 아이디어가 있었지만 POP3만을 처리할 수 있었고, 아마추어티가 나는 코딩이었다. 오승홍 씨는 똑똑하기는 하지만 경험이 부족한 프로그래머였고, 코딩에서 그 두 가지 특징을 모두 볼 수 있었다. 칼의 코드는 전문가가 만든 탄탄하면서 더 나은 코드였으나, 몇 가지 중요하면서도 약간의 잔머리가 있어야 구현할 수 있는 fetchpop의 기능들이 (내가 추가한 기능들을 포함해) 빠져 있었다.

머물러 있을 것인가, 옮겨 갈 것인가? 옮겨 간다면 더 나은 개발 기반을 위해 이미 해놓은 코딩을 포기해야만 했다.

옮겨 가는데 실질적인 동기가 됐던 것은 다중 프로토콜 지원 여부였다. POP3가 우체국 서버 프로토콜 중에서 가장 널리 쓰이는 것이긴 했지만 유일한 프로토콜은 아니었다. fetchpop을 비롯해 다른 경쟁자들은 POP2, RPOP 또는 APOP를 지원하지 않았고, 나는 당시에 재미 삼아서 가장 최근에 고안된 가장 강력한 우체국 프로토콜 [IMAP](https://web.archive.org/web/19990429060232/http://www.imap.org/)`아이맵: Internet Message Access Protocol`을 지원해 볼까 하는 생각을 하고 있었다.

하지만 옮겨가는 것이 좋은 생각이라는 좀 더 이론적인 이유도 있었다. 리눅스를 알기 오래 전에 배운 교훈이었다.

 3. ‘갖고 있는 것을 버릴 계획을 세우라. 언젠가는 버리게 될 것이다.’ (프레더릭 브룩스, 『맨먼스 미신』 11장 중에서)[^2-6]

[^2-6]: 역자주 『The Mythical Man-Month, Frederick Brooks, Addison-Wesley, Anniversary Edition, 1995, ISBN: 9780201835953』. 한국에는 『맨먼스 미신, 프레더릭 브룩스, 김성수 옮김, 케이앤피, 2007년, ISBN: 9788995982204』으로 번역·출판되었다. 인용된 문구는 한국어 번역판에 다음과 같이 옮겨져있다. 「그러므로 프로그램 개발에서는 하나는 내버린다는 계획을 잡아야 한다. 계획하든 않든 버릴 수밖에 없기 때문이다.(156페이지)」

다른 말로 하자면, 첫 번째 해결책을 구현할 때까지도 진짜 문제가 무엇인지 이해하지 못하는 경우가 종종 있다는 것이다. 두 번째가 되어서야 어떻게 하는 것이 옳은 것인지 충분히 알게 될 수 있다. 따라서 만일 올바른 방법을 찾고 싶다면 최소한 한 번은 처음부터 다시 시작할 준비를 해 두어야 한다.[^2-7]

[^2-7]: 원주 컴퓨터과학 분야에 좋은 격언을 남기고 있는 존 벤틀리(Jon Bentley)는 그의 책 『Programming Pearls, Addison-Wesley, 1999, ISBN: 9780201657883』에서 ‘만약 하나를 버릴 계획을 했다면, 둘을 버리게 될 것이다’라고 브룩스의 말에 덧붙인다. 이것은 확실히 거의 맞는 말이다. 브룩스와 벤틀리의 논점은 단순히 첫 번째 시도가 잘못될 것을 예상해야만 한다는 것이 아니라, 올바른 아이디어로 처음부터 다시 시작하는 것이 엉망인 걸 바로잡으려 애쓰는 것보다 흔히 더 효율적이라는 것이다.

“그래, fetchpop을 고친 것은 내 첫 번째 시도였어”라고 자신에게 말하고 나서, 나는 팝클라이언트로 옮겨갔다.

1996년 6월 25일, 칼 해리스에게 내 첫 번째 팝클라이언트 패치를 보낸 후에 나는 그가 팝클라이언트에 이미 흥미를 잃었다는 것을 알게 됐다. 코딩이 좀 지저분했고, 자잘한 버그가 널려있었다. 수정해야 할 것이 많았으므로, 내가 프로그램을 넘겨받는 것이 합리적이라는 데에 칼과 나는 곧 동의했다.

내가 알아차리지 못하는 사이에 프로젝트가 차츰 궤도에 오르기 시작했다. 나는 이미 POP 클라이언트에 사소한 패치만 하는 것이 아니었다. 클라이언트 하나를 통째로 관리했으며, 내 머리에서는 커다란 변화가 될 아이디어들이 솟아나고 있었다.

코드 공유를 장려하는 소프트웨어 문화에서는 이런 방식으로 프로젝트가 진화하기 마련이다. 이렇게 말할 수 있다.

 4. 적절한 태도를 갖고 있으면, 흥미로운 문제가 당신을 찾아갈 것이다.

하지만 칼 해리스의 태도가 훨씬 더 중요했다. 그는 이것을 이해하고 있었다.

 5. 프로그램에 흥미를 잃었다면, 프로그램에 대한 당신의 마지막 의무는 능력 있는 후임자에게 프로그램을 넘겨주는 것이다.

토론할 필요도 없이 칼과 나는 우리가 가장 좋은 해결책을 찾고 있다는 것을 알고 있었다. 우리에게 남은 한 가지 문제는 내가 적임자라는 것을 입증할 수 있느냐 하는 것이었다. 내가 그것을 증명하자 그는 기꺼이, 그리고 신속하게 행동했다. 훗날 내 차례가 오면 나 또한 그만큼 잘할 수 있기를 바란다.

## 사용자가 있다는 것의 중요성

그래서 내가 팝클라이언트를 넘겨받았다. 내가 팝클라이언트 사용자들을 넘겨받았다는 것도 그에 못지않게 중요하다. 사용자가 있다는 것은 매우 좋은 일이다. 당신이 누군가의 필요를 충족시켜주고 있으며 일을 잘 해나가고 있다는 것을 보여주기 때문만은 아니다. 적절하게 유도해 준다면 사용자는 공동 개발자가 될 수도 있다.

유닉스 전통의 또 다른 강점, 즉 많은 수의 사용자가 동시에 해커이기도 하다는 것을 리눅스는 좋은 의미로서 극단까지 밀어붙였다. 소스 코드가 공개돼 있기 때문에 그들은 효과적인 해커가 될 수 있다. 이것은 디버깅 시간을 줄이는데 엄청난 도움이 됐다. 조금만 격려해주면 사용자들은 문제를 분석하고 해결책을 제시하며, 도움없이 혼자 일할 때보다 훨씬 빨리 코드를 개선하도록 해준다.

 6. 사용자를 공동 개발자로 생각하면 코드가 다른 어떤 방법보다 빠른 속도로 개선되며 효율적으로 디버깅할 수 있다.

이 효과의 위력은 과소평가되기 쉽다. 사실, 오픈소스 세계의 우리조차 시스템 복잡도에 대항해 많은 수의 사용자가 얼마나 힘이 되는지를 리누스 토르발스가 보여주기 전까지는 과소평가하고 있었다.

실제로 나는 리누스의 가장 영리하고 중요한 해킹은 리눅스 커널을 만든 것이 아니라 리눅스 개발 모델을 만든 것이라고 생각한다. 리누스에게 이 의견을 말했더니 그는 씩 웃으면서 조용히 여러 번 하던 말을 되풀이했다. “난 기본적으로 매우 게으른 사람이라서, 실제로는 다른 사람들이 해놓은 일로 공로를 인정받곤 해요.” 여우같은 게으름이라 할 수 있다. 혹은 로버트 하인라인`Robert Heinlein, 1907~1988`의 소설 속 등장인물처럼 “실패하기에는 너무 게으르다”라고 할 수도 있을 것이다.[^2-8]

[^2-8]: 역자주 여우 같은 게으름(lazy like a fox)이란 최소의 노력으로 최대의 결과를 낸다는 의미다. 흔히 ‘창조적 게으름’이나 ‘건설적 게으름’이란 표현으로도 많이 인용된다. <http://en.wikipedia.org/wiki/Time_Enough_for_Love> 참고.

되돌아보면, 리눅스의 성공과 방법론은 GNU 이맥스 리스프 라이브러리와 리스프 코드 아카이브에서 그 선례를 찾아볼 수 있다. 이맥스의 C 코드 핵심이나 대부분의 다른 FSF 도구들의 성당 건축 방식과 대조적으로 리스프 코드 풀`pool`의 진화는 유동적이고 사용자가 주도했다. 아이디어와 이맥스 모드들의 원형은 안정적인 최종 형태를 갖추기까지 종종 서너 번씩 다시 쓰였다. 느슨하게 묶인 공동 작업이 인터넷으로 인해 가능해졌고, 리눅스에서처럼 매우 자주 일어나는 일이 됐다.

사실 페치메일 이전에 나 자신의 가장 성공적인 해킹은 아마 이맥스 VC 모드였을 것이다. 세 명의 사람들과 이메일로 리눅스와 비슷한 협동 작업을 했고, 지금까지 그 중 한 명인 (이맥스의 저자면서 [자유 소프트웨어 재단](http://www.fsf.org/)의 설립자인) 리처드 스톨먼만을 만나보았다. VC 모드는 SCCS, RCS, CVS를 위한 이맥스 안의 프런트 엔드였고, ‘원 터치’ 판 관리 기능을 제공했다.[^2-9] 이것은 누군가 만들어 놓은 작고 조악한 sccs.el 모드로부터 진화한 것이다. VC의 개발은 이맥스와는 다르게 이맥스 리스프 코드가 발표와 테스트, 개선의 주기를 매우 빨리 반복할 수 있었기 때문에 성공했다.

[^2-9]: 역자주 SCCS(Source Code Control System)와 [RCS(Revision Control System)](http://www.gnu.org/software/rcs/), [CVS(Concurrent Versions System)](http://www.nongnu.org/cvs/)은 모두 소스 코드 판 관리 소프트웨어다. 최근에는 [서브버전(Subversion)](http://subversion.apache.org/)과 [기트(Git)](http://git-scm.com/)가 많이 쓰인다.

코드를 법적으로 GPL에 묶어 두려는 FSF의 정책은 한 가지 예기치 못한 부작용을 가져왔다. 그것은 FSF가 시장 개발 방식을 사용하는 절차가 까다로워졌다는 점이다.  이는 저작권법 체계에서 생길 수 있는 문제에 대비해 GPL 코드를 면역시키기 위해 20행 이상의 개인적 공헌에 대해서는 저작권을 양도받아야 한다고 FSF가 믿기 때문이다. BSD와 MIT의 ‘X 컨소시엄 이용허락`license`’을 사용하는 사람에게는 이런 문제가 없다. 그들은 누군가가 문제를 일으킬 동기가 될만한 권리를 가지려 하지 않는다.

이맥스 외에도 두 개로 층이 나뉘는 구조를 갖는 사용자 공동체와 소프트웨어 제품이 있다. 즉, 성당 개발 방식의 핵심부와 시장 개발 방식의 도구상자`toolbox` 부분이 한데 결합해 있는 것이다. 그 중 하나가 상용 데이터 분석 및 시각화 도구 매트랩`MATLAB: MATrix LABoratory`이다. 매트랩과 이와 유사한 구조를 갖는 제품의 사용자들은 프로그램을 만지작거릴 수 있는 크고 다양한 공동체 안에서 수행과 숙성, 혁신이 끊임없이 일어나고 있는 곳은 대부분 개방된 도구 부분 쪽이라는 것을 보여준다.

## 일찍, 그리고 자주 발표하라

일찍 그리고 자주 발표하는 것은 리눅스 개발 모델에서 중요한 부분이다. 나를 포함한 대부분의 개발자는 아주 사소한 프로젝트가 아니라면 이런 정책이 나쁘다고 생각했다. 초기 판에는 예외 없이 버그가 많고, 개발자라면 사용자의 인내심을 시험하고 싶지 않기 때문이다.

이런 믿음이 성당 개발 방식을 더 선호하게 했다. 만일 가장 중요한 목표가 사용자로 하여금 가능한 적은 버그를 발견하게 하는 것이라면 6개월에 한 번씩 혹은 그보다 덜 자주 발표하면서 그동안 죽으라고 일하는 편이 나을 것이다. 이맥스 C 코드의 핵심은 이런 식으로 개발됐다. 그러나 리스프 라이브러리는 그렇지 않았다. 이맥스의 발표 주기와 관계없이 언제든 새로운 개발 코드 판을 찾을 수 있었으며, FSF의 통제권 밖에 있는 리스프 라이브러리들이 있었기 때문이다.[^2-10]

[^2-10]: 원주 인터넷의 폭발적인 성장 이전에 유닉스와 인터넷의 전통과 관계없이 생겨난 성공적인 오픈소스 시장 방식 개발의 예가 있다. 그중 하나가 1990∼1992년 사이에 개발된 DOS 컴퓨터에서 주로 사용된 압축 유틸리티 [info-Zip](https://web.archive.org/web/19990508110143/http:/www.cdrom.com/pub/infozip/)이다. 또 다른 하나는, 역시 DOS 용이지만 1983년에 시작된 RBBS(Remote Bulletin Board System)다. 인터넷 메일과 BBS 간 파일 공유 기술이 매우 큰 기술적 이점을 갖고 있었지만, RBBS는 매우 강한 공동체를 성장시켰기 때문에 1999년 중반인 현재까지 상당히 정기적인 릴리스를 발표하고 있다. Info-Zip 공동체가 인터넷 메일에 어느 정도 의존적인데 반하여, RBBS 개발자 문화는 TCP/IP 인프라에 완전히 독립적인 RBBS의 튼튼한 온라인 공동체에 실제로 근거하고 있다.

이들 중 가장 중요한 아카이브는 오늘날 대형 리눅스 아카이브들의 정신과 많은 기능이 이미 있던 오하이오주의 이맥스 리스프 아카이브였다. 하지만 우리가 하는 일에 대해, 그리고 FSF의 성당 개발 모델의 문제점들에 대해 그 아카이브의 존재가 무엇을 제시하는 지는 우리 중 소수만이 진지하게 생각하고 있었다. 나는 오하이오 코드를 공식적인 이맥스 리스프 라이브러리에 정식으로 합치려는 시도를 1992년에 했으나 정치적인 문제에 부딪쳤고 큰 실패를 겪었다.

1년 후, 리눅스가 널리 알려지기 시작했고, 무언가 다르면서 훨씬 바람직한 일이 일어나는 것이 확실해 보였다. 리누스의 열린 개발 정책은 성당 개발과 완전히 반대되는 것이었다. 썬사이트`SunSITE`와 tsx-11 아카이브가 싹텄고, 다중 배포 방식이 퍼지기 시작했다. 그리고 이 모든 것이 이전 어느 소프트웨어보다 자주 릴리스되는 핵심 시스템에 의해 주도됐다.

리누스는 가장 효과적인 방식으로 사용자를 공동 개발자로 여겼던 것이다.

 7. 일찍 발표하고 자주 발표하라. 그리고 사용자의 소리에 귀를 기울여라.

리누스의 혁신은 (그 비슷한 것이 오랫동안 유닉스 세계의 전통이었기 때문에) 그가 이렇게 했다는 점보다는 그가 개발하고 있던 리눅스 커널의 복잡성에 비견될 만한 수준까지 끌어올렸다는 데 있다. 리눅스 개발 초기인 1991년경에 그는 하루에 한 번 이상 새로운 커널을 발표하기까지 했다. 리누스는 공동 개발자라는 자신의 기반을 잘 만들었고, 인터넷이라는 지렛대를 이용해 누구보다 열심히 협동 작업에 몰두했기 때문에 이 방식은 성공했다.

하지만 어떤 과정을 거쳐 성공할 수 있었을까? 내가 재현할 수 있는 것일까, 아니면 리누스 토르발스만의 천재성이 필요한 것일까?

그렇게 생각하지는 않았다. 리누스가 매우 뛰어난 해커라는 점은 인정한다. 우리 중에 상업용 제품 못지 않은 운영체제 커널을 만들 수 있는 사람이 몇이나 될까? 그러나 리눅스는 놀랄만한 개념적 전진을 이루어 내지는 않았다. 리누스는 적어도 지금까지는 리처드 스톨먼이나 NeWS`Network extensible Window System`와 자바`Java`를 만든 제임스 고슬링`James Gosling`과 같은 혁신적인 설계를 이루어낸 천재는 아니었다. 대신 리누스는 공학의 천재인 것으로 보인다. 버그와 개발의 막다른 골목을 피하는 육감, 그리고 A점에서 B점까지 가는데 최소 노력 경로를 찾아내는 요령을 갖췄다. 실제로 리눅스의 전반적인 설계는 이런 특성을 바탕으로 하며, 리누스의 본질적으로 보수적이고 단순한 설계 방식을 반영하고 있다.

빠른 릴리스와 인터넷을 매체로 사용한 것이 우연히 이루어진 것이 아니라 리누스의 공학적 천재성에 기인한 최소 노력 경로에 대한 통찰력의 통합적 부분이었다면 그가 최대화하고 있는 것은 무엇이었을까? 기계에서 무엇을 뽑아냈던 것일까?

해답은 질문 안에 있다. 리누스는 그의 해커와 사용자들에게 지속적인 자극과 보답을 제공했다. 리눅스 개발에 참여함으로써 자기만족을 얻으리라는 전망에 자극받았고, 그들이 하는 일이 계속해서 어떤 때는 날마다 향상된다는 것이 보답이 됐다.

리누스는 만약 처리하기 곤란한 심각한 버그가 발견되면, 사용자들이 떨어져 나갈 위험과 코드가 불안정해질 가능성을 무릅쓰고 디버깅과 개발에 투입되는 공수`the number of person-hours`의 최대화에 목표를 뒀다. 리누스는 다음과 같은 신념을 지닌 것처럼 행동했다.

 8. 충분하게 많은 베타 테스터와 공동 개발자가 있으면, 거의 모든 문제는 빠르게 파악될 것이고 쉽게 고치는 사람이 있게 마련이다.

덜 형식적으로 말하자면, ‘보는 눈이 충분하게 많으면, 찾지 못할 버그는 없다.’ 나는 이것을 ‘리누스의 법칙`Linus’s Law`’이라고 부른다.

원래 나의 공식적인 서술은 모든 문제는 ‘누군가에게는 간단할 것이다’였다. 리누스는 문제를 이해하고 고치는 사람이 그 문제를 처음 파악한 사람과 항상 같은 것이 아니라 오히려 다른 경우가 더 많다고 이의를 제기했다. 리누스의 얘기로는, “누군가 문제를 발견합니다. 그리고 또 다른 누군가가 그 문제를 이해하지요. 문제를 발견해 내는 것이 더 중요한 일이라고 분명히 말할 수 있습니다.” 하지만 가장 중요한 점은 사람이 충분하게 많을 경우, 이 두 가지 모두 매우 빨리 일어나는 경향이 있다는 것이다.

내 생각에는 여기에 성당 방식과 시장 방식의 핵심적인 차이가 있다. 프로그래밍의 성당 건축가 관점에서 보자면 버그와 개발 문제는 어렵고, 까다로우며 심오한 현상이다. 문제를 해결하려면 헌신적인 소수의 사람이 몇 달이고 정밀한 검사를 수행해야 모두 끝났다고 확신할 수 있다. 따라서 발표 사이의 기간이 길어지고, 오랫동안 기다린 릴리스가 완벽하지 않을 때는 필연적으로 실망이 따른다.

반면, 시장 관점에서는 보통 버그가 쉽게 해결될 수 있다고 본다. 최소한 새로운 릴리스가 나올 때마다 그것과 씨름하는 수천의 열정적인 공동 개발자에게 알려진다면 금방 쉽게 해결할 수 있는 문제로 바뀐다. 따라서 더 많은 교정을 받고 싶다면 자주 발표해야 하고 덤으로 서투른 부분이 드러나더라도 잃을 것이 적다는 이점이 있다.

바로 이것이다. 이것으로 충분하다. ‘리누스의 법칙’이 틀렸다면 리눅스 커널과 같이 복잡한 시스템은 어떤 것이라도 수많은 손에 의해 해킹되면서 일찍이 볼 수 없었던 나쁜 상호작용과 발견하지 못한 ‘심오한’ 버그들에 의해 어느 시점에선가 붕괴하고 말았을 것이다. 반면에 만일 그 법칙이 옳다면 그 법칙만으로도 상대적으로 적은 리눅스의 버그를 설명할 수 있다.

그리고 이 법칙이 옳다는 것에 너무 놀라지 말아야 한다. 수년 전 사회학자들은 비슷하게 전문적인 혹은 비슷하게 무지한 관찰자들로 이루어진 대중의 평균적인 의견이 그 관찰자 중 무작위로 뽑은 한 명의 의견보다 더 신뢰할 만하다는 점을 발견했다. 사회학자들은 이것을 ‘델파이 효과`Delphi Effect`’라고 부른다. 리누스는 이 효과가 운영체제를 디버깅하는 데도 적용될 수 있다는 것을 보여주었다. 델파이 효과는 OS 커널만큼 복잡한 개발까지도 다룰 수 있다.[^2-11]

[^2-11]: 원주 새로운 개념은 아니지만, 결국 투명성과 동료검토가 OS 개발의 복잡성을 줄이는 데 중요하다는 것이 밝혀졌다. 1965년, 시분할 운영체제의 역사 초기에 멀틱스(Multics)의 공동 설계자 페르난도 코바토 (Fernando Corbato)와 빅토르 비소츠키(Victor Vyssotsky)는 [다음과 같이 썼다](http://www.multicians.org/fjcc1.html). 「멀틱스는 충분하게 동작할 때 공개하기로 되어 있었다. (중략) 그런 공개는 2가지 이유로 바람직하다. 첫째, OS는 관심 있는 사람에 의한 자발적인 비판과 철저한 검토를 견딜 수 있어야만 한다. 둘째, 복잡성이 증가하는 시대에 내부 운영체제를 가능한 명료하게 만들려는 현재와 미래의 시스템 설계자에게 그것은 기본적인 시스템 문제를 가능한 한 분명히 드러내기 위해 필수적이다.」

델파이 효과를 촉진하는 리눅스의 한 가지 특성은 기여자가 자신이 참여할 프로젝트를 직접 선택한다는 데 있다. 이 글의 초판에 의견을 준 사람 중 한 명은, 기여가 무작위 표본으로부터 오는 것이 아니라 그 소프트웨어를 사용하고, 그것이 어떻게 동작하는지 학습하며, 자신이 맞닥뜨린 문제를 해결하려고 시도하고, 또한 명백히 합리적인 해결책을 실제로 만들어내기에 충분한 관심이 있는 사람들에게서 온다고 지적해 주었다. 이런 단계를 모두 거친 사람이라면 기여할 수 있는 유용한 무언가를 가졌을 가능성이 매우 높다.

고맙게도 제프리 덧키`Jeffrey Dutky`는 리누스의 법칙을 ‘디버깅은 병렬 처리가 가능하다’는 말로 표현할 수 있음을 지적해 주었다. 제프리는 디버거들이 디버깅하려면 의사소통을 조정해 주는 개발자가 필요하지만, 디버거들 사이에는 그다지 조정이 필요하지 않다고 진술한다. 따라서 개발자를 추가하는 데서 생기는 기하급수적인 복잡성과 관리의 어려움이 디버깅에는 짐이 되지 않는다.

실제로 리눅스 세계에서는 디버거의 작업이 중복됨으로써 생기는 이론적인 효율 저하가 거의 문제가 된 적이 없는 것으로 보인다. ‘빨리, 그리고 자주 발표하는 정책’의 효과 중 하나는 피드백되는 수정 사항을 빨리 전파함으로써 중복을 최소화한다는 것이다.

프레더릭 브룩스는 이와 관련해 다음과 같은 말을 했다. “널리 사용되는 프로그램의 유지보수에 드는 비용은 보통 개발 시 드는 비용의 40퍼센트나 그 이상입니다. 놀랍게도 이 비용은 사용자의 수에 큰 영향을 받습니다. 더 많은 사용자가 더 많은 버그를 찾아냅니다.”

사용자가 많아지면 프로그램을 시험해보는 방법이 더 늘어나기 때문에 버그를 더 많이 잡아낼 수 있다. 이 효과는 사용자가 공동 개발자일 때 더욱 커진다. 각각의 사람이 버그를 찾아낼 때 조금씩 다른 개념의 집합과 분석 도구를 사용해 문제를 다른 각도에서 접근하기 때문이다. ‘델파이 효과’는 바로 이런 편차에서 비롯된 것으로 보인다. 또한, 디버깅이라는 특정한 환경에서 이 편차는 노력의 중복을 줄여주는 경향이 있다.

따라서 더 많은 베타 테스터가 있는 것은 개발자의 관점에서 현재 ‘가장 심오한’ 버그의 복잡성을 줄여주지는 않겠지만, 누군가의 도구가 문제에 딱 들어맞아 그 버그가 그 사람에게는 쉽게 잡을 수 있는 것이 될 가능성을 높여준다.

리누스도 물론 해야 할 일이 있었다. 심각한 버그가 있을 때를 대비해 리눅스 커널은 잠재 사용자들이 최종적으로 ‘안정된’ 판을 사용할 수도 있고, 새로운 기능을 사용하기 위해 버그가 있을 수 있는 최신 판을 사용할 수도 있게 번호가 붙여졌다. 이 전술을 아직 리눅스 해커 대부분이 따라 하지는 않고 있지만, 아마도 앞으로 따라하게 될 것이다. 둘 중 선택이 가능하다는 사실이 양쪽 모두를 더 매력적으로 보이게 한다.

## 장미가 장미다우려면

리누스의 행동을 연구하고 그것이 왜 성공적이었는지에 대한 이론을 만든 뒤에, 나는 이 이론을 물론 훨씬 덜 복잡하고 덜 야심적인 내 새로운 프로젝트에 적용해 보기로 했다.

그러나 내가 가장 먼저 한 일은 팝클라이언트를 더 재조직화하고 단순화한 것이었다. 칼 해리스의 구현 방식은 매우 건강했지만, 많은 C 프로그래머들처럼 일종의 불필요한 복잡성을 보이고 있었다. 그는 코드는 중심적인 것으로, 자료 구조는 코드를 받쳐주는 것으로 취급했다. 그 결과 코드는 아름다웠지만, 자료구조는 임시변통으로 설계됐고 보기에 좋지 않았다. 최소한 옛 리스프 해커의 높은 기준에서 보자면 말이다.

그리고 코드와 자료구조를 개선하는 것 말고도 나는 또 다른 목적이 있었다. 그것은 팝킅라이언트를 내가 완전히 이해하는 무엇인가로 진화시키는 것이었다. 이해하지 못하는 프로그램의 버그를 수정하는 책임을 맡는 것은 괴로운 일이다.

처음 한 달 정도가 지날 동안 나는 그저 칼의 기본적인 설계가 어떤 의미가 있는지 따라다니기만 했다. 내가 처음으로 중요한 수정을 가한 것은 IMAP 지원이었다. 프로토콜 컴퓨터를 일반적인 드라이버와 (POP2, POP3, IMAP) 세 가지 메소드 테이블을 지원하는 것으로 재조직했다. 이것과 그 이전 변경들은 프로그래머가 기억할 만한 일반적인 원리를 보여준다. 특히 C와 같이 즉흥적으로 프로그래밍하기 힘든 언어에서는 더욱 그렇다.

 9. 자료구조를 훌륭하게 만들고 코드를 멍청하게 만드는 것이 그 반대 경우보다 훨씬 잘 작동한다.

브룩스의 책 9장에 이렇게 쓰여있다. ‘내게 코드를 보여주고 자료구조를 숨긴다면 나는 계속 어리둥절할 것이다. 자료구조를 보여준다면 코드는 볼 필요도 없이 뻔한 것이다.’ 사실 브룩스는 ‘순서도’와 ‘테이블’이라고 이야기했다.[^2-12] 하지만 30년간 변해온 용어와 문화를 고려한다면 거의 똑같은 말이라고 할 수 있다.

[^2-12]: 역자주 「데이터나 테이블을 다시 표현함으로써 이뤄지는 전략적 발명은 더욱 흔하다. 순서도만 보여주고 테이블을 보여주지 않으면 오리무중 상태에서 빠져나올 수 없다. 테이블을 보면 대개 순서도는 볼 필요도 없이 모든 것이 명확해진다.(한국어 번역판 141페이지)」

1996년 9월 초, 일을 시작하고 6주가 지난 시점에서 나는 이름을 바꿀 때가 됐다고 생각했다. 이 프로그램은 이미 POP만을 지원하는 것이 아니었다. 하지만 설계상 정말로 새로운 것은 들어 있지 않았기 때문에 머뭇거리고 있었다. 내가 만든 팝클라이언트`popclient`는 아직 스스로 정체성을 확립하지 못하고 있었다.

페치메일이 어떻게 SMTP 포트로 가져온 메일을 포워딩해야 하는지 알고 난 뒤에는 상황이 급변했다. 그에 대해서는 잠시 후에 이야기하겠다. 나는 리누스 토르발스가 옳은 방법으로 일을 해냈다는 내 이론을 시험하려고 이 프로젝트를 수행했다고 말한 바 있다. 어떻게 시험했을까? 다음과 같은 방법을 사용했다.

* 일찍 그리고 자주 발표했다. 발표 간격이 10일을 넘는 경우는 거의 없었으며, 개발에 몰두했을 때는 하루에 한 번씩 발표했다.
* 페치메일에 대한 일로 내게 연락하는 사람은 누구든지 베타 테스터 목록에 올렸다.
* 새로 발표할 때마다 베타 테스터들에게 떠들썩하게 발표를 알리고, 사람들이 참여하도록 격려했다.
* 그들의 이야기를 들었다. 설계 결정에 대해 투표하기도 했고, 패치나 피드백을 보내올 때마다 베타 테스터들을 구슬렸다.

이 단순한 방법들은 즉각 효력을 나타냈다. 프로젝트를 시작할 때부터 개발자라면 학수고대할 만한 버그 리포트와 때로는 훌륭하게 수정된 코드를 받을 수 있었다. 사려 깊은 비판과 감사 메일, 기능 제안들을 받았다. 여기서 다음과 같은 결론을 이끌어낼 수 있다.

10. 베타 테스터를 가장 중요한 자원으로 여긴다면 그들은 정말 가장 중요한 자원이 되어준다.

페치메일의 성공을 재는 재미있는 척도 중 하나는 프로젝트 베타 테스터 메일링리스트인 fetchmail-friends의 크기다. 이 글을 쓰고 있을 때 목록에는 249명이 있었고 1주일에 2∼3명이 추가됐다.

1997년 5월 말경 글을 수정할 때 이 리스트에는 300명 가까이 있었지만, 가입자가 조금씩 줄기 시작했다. 그런데 그 이유가 흥미로웠다. 몇몇 사람이 구독을 중단하면서 페치메일이 잘 작동하기 때문에 더 이상 메일링리스트를 볼 이유가 없다고 말했다. 아마 이것이 성숙한 시장 방식 프로젝트가 가지는 정상적인 수명주기 중 하나일 것이다.[^2-13]

[^2-13]: 역자주 이 책의 ‘부록 B: 페치메일 프로젝트 성장에 대한 통계’에서 페치메일의 성장 추세를 참고할 수 있다.

## 팝클라이언트가 페치메일이 되다

페치메일 프로젝트에서 큰 전환이 일어났던 것은 해리 호흐하이저`Harry Hochheiser`가 클라이언트 컴퓨터의 SMTP 포트로 메일을 포워딩하는 대략적인 코드를 보내준 때였다. 보자마자 이 기능을 안정적으로 구현한다면 다른 모든 배달 방법은 구식이 되리라는 것을 깨달았다.

여러 주 동안 나는 페치메일을 조금씩 뜯어고쳤는데, 인터페이스 설계가 작동하긴 했지만 지저분하다고 느끼고 있었다. 우아하지도 않고 몇 안 되는 옵션들이 너무 여기저기 흩어져 있었다. 가져온 메일을 메일상자`mbox` 파일에 부어놓을 것인지, 표준 출력으로 내보낼 것인지 결정하는 옵션이 특히 골칫거리였지만 왜 그런지 확실히 깨닫지는 못했다.

(인터넷 메일의 기술적인 부분에 관심이 없다면, 다음 두 문단은 건너뛰어도 무방하다.)

SMTP 포워딩을 생각하자 그동안 팝클라이언트가 너무 많은 것을 해내려고 했다는 것을 알게 됐다. 팝클라이언트는 MTA`Mail Transport Agent`와 MDA`Mail Delivery Agent`의 기능을 모두 갖추도록 설계됐다. SMTP 포워딩만 할 수 있다면 MDA 기능을 없애고 순수한 MTA가 될 수 있었다. 센드메일과 마찬가지로 최종적인 메일 배달은 다른 프로그램에 맡기면 된다.[^2-14]

[^2-14]: 역자주 MDA로 가장 많이 사용된 프로그램으로 [procmail](http://www.procmail.org/)을 들 수 있다.

TCP/IP를 지원하는 플랫폼이라면 거의 어디에나 25번 포트가 기다리고 있는데 무엇 때문에 복잡한 MDA 기능을 설정하거나 메일상자를 잠그고`file locking`덧붙이는 문제 때문에 고생하는가? 더구나 포워딩을 사용하면 가져온 메일이 평범한 SMTP 메일처럼 보일 것이고, 우리가 원하는 것이 바로 그것이었는데 말이다.

(이제 다시 본래 이야기로 돌아간다.)

몇 가지 배울 점이 있었다. 먼저, SMTP 포워딩에 대한 아이디어는 내가 리누스의 방법을 모방하려고 의식적으로 노력한 것에 대한 가장 큰 보답이었다. 사용자 한명이 내게 끝내주는 아이디어를 주었으며, 내가 해야 했던 일은 그 의미를 이해하는 것뿐이었다.

 11. 좋은 아이디어를 생각해 내는 것 다음으로 중요한 일은 사용자가 알려준 좋은 아이디어를 깨닫는 것이다. 때로는 이편이 더 나을 수도 있다.

흥미롭게도 만일 당신이 다른 사람에게 얼마나 많은 빚을 지고 있는지 자기비하라고 느껴질 정도로까지 솔직하게 털어놓는다면, 대개의 사람은 혼자서 거의 모든 일을 해내고서 천재성에 대해 겸손해하는 것처럼 당신을 대한다는 것을 곧바로 알게될 것이다. 리누스의 경우를 보라!

1997년 8월, 펄 콘퍼런스에서 이 글을 발표할 때 래리 월`Larry Wall`이 첫 번째 줄에 앉아 있었다. 바로 윗줄에 도달했을 때 그는 부흥사라도 된 것처럼 외쳤다. “형제여, 이야기하시오, 이야기를!” 청중들 모두가 펄을 만든 래리에게도 이것이 적용된다는 것을 알았기 때문에 웃음을 터뜨렸다.

똑같은 정신으로 프로젝트를 몇 주 진행해 나가자, 나는 사용자뿐 아니라 이야기를 전해 들은 다른 사람들로부터 비슷한 칭송을 받기 시작했다. 나는 그런 이메일 중 몇몇을 따로 보관해 두었다. 나중에 내 삶이 가치 있는 것이었는지 의심스러워질 때 그 메일들을 다시 꺼내볼 생각이다. :-)

모든 종류의 설계에 대해 적용할 수 있는 두 가지 더 기본적이며 비정치적인 교훈이 있다.

 12. 종종 가장 충격적이고 혁신적인 해결책은, 당신 자신이 문제에 대해서 가지고 있는 개념이 잘못돼 있다는 것을 깨닫는 것에서 나온다.

나는 팝클라이언트를 MTA와 MDA 기능을 다 갖추고 복잡한 지역 배달 모드까지 갖춘 것으로 개발해 나가면서 잘못된 문제를 풀려고 노력하고 있었다. 그래서 페치메일의 설계는 가장 기초적인 것부터 재고하여 SMTP 포트로 메일을 배달하는 인터넷 메일 경로의 한 부분인 순수 MTA가 돼야 했다.

개발 도중에 벽에 부딪힌다면, 다음번 패치 후에 무엇을 해야 할지 모르겠다면, 그때는 정답을 가졌는지 생각할 것이 아니라 질문이 올바른 것인지 의문을 가져봐야 하는 경우가 종종 있다. 아마도 문제의 틀을 다시 잡아야 할 것이다.

그래서 나도 내 문제의 틀을 다시 잡았다. 분명히 제대로 일을 진행하려면 (1) SMTP 포워딩 지원 기능을 일반 드라이버에 포함하고, (2) SMTP 포워딩을 기본 모드로 만들고, (3) 최종적으로는 다른 배달 모드들, 특히 ‘파일로 배달하기’와 ‘표준 출력으로 배달하기’를 제거해야 했다.

나는 단계 (3)에서 조금 머뭇거렸는데, 그 이유는 오랫동안 팝클라이언트를 사용하면서 다른 배달 모드에 의존하고 있을 사용자들의 심기를 불편하게 만들고 싶지 않아서였다. 이론적으로는 그들 모두 즉시 .forward 파일이나 센드메일 외의 비슷한 프로그램으로 전환하여 동일한 결과를 얻을 수 있었다. 실제로는 다른 프로그램으로 전환하는 것 자체가 큰일이 될 것이다.

하지만 단계 (3)을 실행하고 나자 이점이 매우 많은 것으로 나타났다. 드라이버 코드 중 가장 힘든 부분이 사라졌다. 설정이 엄청나게 간단해졌다. 시스템의 MDA와 사용자의 메일상자를 일일이 찾아다니며 굽실거릴 필요가 없어졌고, OS가 파일 잠금을 지원하는지 걱정할 필요도 없어졌다.

게다가 메일을 잃어버릴 한 가지 가능성도 사라졌다. ‘파일로 배달하기’를 선택했을 때 디스크가 꽉 차 있으면 메일이 사라져 버렸는데, SMTP 포워딩에서는 SMTP 리스너가 메시지 배달이 가능하거나 나중에 배달할 수 있도록 스풀해 놓기 전에는 OK를 돌려주지 않기 때문에 이런 일이 일어날 수가 없다.

한두 번 실행해봐서는 느끼지 못하겠지만, 성능도 향상됐다. 변경에 따른 그다지 중요하지 않은 또 하나의 이점이라면 매뉴얼 페이지가 훨씬 간단해 졌다는 것이다.

나중에 나는 사용자가 지정한 지역 MDA를 통해 배달하는 기능을 다시 넣어야 했다. 동적 SLIP을 포함해 몇몇 애매한 상황을 다뤄야 했기 때문이다. 하지만 처음보다 훨씬 간단한 방법을 찾아낼 수 있었다.

교훈이라면? 낡아서 사용할 수 없는 기능이라면, 효율을 떨어뜨리지 않고 제거할 수 있을 때는 망설이지 말고 제거해 버려라. 아동 도서 작가이자 남는 시간에 비행기 조종과 설계를 했던 앙투안 드 생텍쥐페리`Antoine de Saint-Exupery, 1900∼1944`는 이렇게 말했다.

 13. “설계에서 완벽함이란 더 이상 추가할 것이 없을 때 이루어지는 것이 아니라 더 이상 버릴 것이 없을 때 이루어진다.”

코드가 더 나아지고 간단해지고 있을 때가 바로 일이 제대로 돼가고 있다는 것을 알게 되는 때다. 그리고 그 과정에서 페치메일의 설계는 그 조상 격인 팝클라이언트와 다른 자신만의 정체성을 갖게 됐다.

이름을 바꿀 때가 된 것이다. 새로운 설계는 예전의 팝클라이언트보다 센드메일과 비슷해 보였다. 둘 다 MTA였으나 센드메일은 푸시`push` 후에 메일을 배달했고 새로운 팝클라이언트는 풀pull 후에 메일을 배달했다. 그래서 두 달 후에 나는 팝클라이언트의 이름을 페치메일로 변경했다.

## 페치메일의 성장

이제는 깔끔하고 혁신적인 설계와 매일 사용하므로 잘 작동하는 것을 알고 있는 코드, 그리고 발전하고 있는 베타 테스터 목록이 있었다. 더 이상 내가 하는 일이 몇몇 사람에게 유용할 수도 있는 사소하고 개인적인 해킹은 아니라는 생각이 서서히 들기 시작했다. 내가 가진 것은 유닉스 박스와 SLIP/PPP로 메일을 주고받는 모든 해커가 정말로 필요로 하는 프로그램이었다.

SMTP 포워딩 기능으로 페치메일은 경쟁에서 멀찍이 앞서 나와 ‘카테고리 킬러’, 그러니까 해당 분야의 다른 프로그램들은 아예 잊힐 만한 경쟁력을 갖추고 자신의 지위를 확고히 하는 고전적인 프로그램이 될 수 있는 능력을 갖추었다.

이런 결과를 계획하거나 목표로 가질 수는 없으리라고 생각한다. 아주 강력한 설계 아이디어로 그런 결과가 불가피하고, 자연스러우며 운명적인 것으로 보이게 함으로써 그런 결과에 도달해야 한다. 그런 아이디어를 구체화해 볼 수 있는 유일한 방법은 수많은 아이디어를 생각하는 것이다. 아니면 다른 사람의 좋은 아이디어를 원래 생각보다 더 멀리 끌고 가 구체화해 보는 것이다.

앤드루 타넨바움`Andrew Tanenbaum`은 교습 도구로 사용하려고 간단한 386용 네이티브 유닉스를 만들려는 원래 아이디어가 있었다. 그는 이 도구의 이름을 미닉스라 지었다. 리누스 토르발스는 미닉스의 개념을 앤드루가 생각했던 것보다 더 멀리 밀고 나갔다. 그래서 리눅스는 굉장한 것이 됐다. 더 작은 규모였지만, 나는 똑같은 방식으로 칼 해리스와 해리 호흐하이저의 아이디어들을 가져와 강하게 밀어붙였다. 리누스나 나나 사람들이 ‘천재가 그러하리라’고 생각하는, 낭만적인 의미에서 ‘독창적’인 것은 아니었다. 하지만 통념과는 반대로 대부분의 과학과 공학, 소프트웨어 개발은 독창적인 천재나 해커의 전설에 의해 이루어지지 않는다.  

결과물은 똑같이 매우 사람을 흥분시키는 것들이다. 사실 모든 해커는 이런 종류의 성공을 얻기 위해 살아간다! 거기에는 내가 기준을 더 높이 잡아야 한다는 의미도 들어있다. 페치메일을 최상의 것으로 만들기 위해 나는 나 자신의 필요뿐 아니라 나와는 상관없지만 다른 사람에게는 필수적인 기능을 포함하고 지원해야 했다. 게다가 프로그램을 단순하고 튼튼하게 유지하면서 그런 일을 해야 했다.

이것을 깨닫고 나서 내가 추가한 매우 중요한 첫 번째 기능은 멀티드롭`multidrop`이었다. 모임이나 사용자들의 메일을 한꺼번에 가지고 있는 메일상자에서 메일을 가져와 각 메일을 개인 수신자에게 보내주는 기능이었다.

멀티드롭 기능을 추가하기로 한 데에는 몇몇 사용자들이 원한다는 것도 있었지만, 가장 큰 이유는 주소 지정을 완전히 구현함으로써 싱글드롭 코드에 있는 버그를 잡아낼 수 있으리라고 생각했기 때문이다. 그리고 그렇게 되었다. [RFC 822](http://www.rfc-editor.org/info/rfc822)의 주소 구문 분석`parsing`을 제대로 구현하는 데 매우 오랜 시간이 걸렸는데, 각각의 조각이 어려웠기 때문이 아니라 각각이 서로 의존하고 있어서 세심하게 신경 써야 했기 때문이었다.

하지만 멀티드롭 주소 지정 역시 매우 훌륭한 설계 결정이었던 것이 확인됐다. 나는 다음과 같은 교훈을 얻을 수 있었다.

 14. 어떤 도구든지 기대하는 방법으로 쓸모가 있어야 하지만 정말 위대한 도구는 사용자가 전혀 기대하지 않았던 용도에 알맞게 된다.

미처 생각하지 못했던 멀티드롭 페치메일의 용도는 메일링리스트를 그대로 유지하면서, 메일 주소에 별칭`alias`을 설정해 SLIP/PPP로 연결된 클라이언트 쪽에서 메일링리스트를 운영하는 것이었다. 이것은 개인 컴퓨터로 ISP 계정을 통해 접속하는 사람이 ISP 별칭 파일`alias file`에 지속적으로 접근하지 않고도 메일링리스트를 운영할 수 있다는 것을 의미한다.

베타 테스터들이 요구한 중요한 변경 사항 중 또 하나는 8비트 MIME`Multipurpose Internet Mail Extensions` 작업이었다. 이것은 내가 코드를 8비트에 대비해 계속 유지해 왔기 때문에 매우 쉬운 일이었다. 이런 기능에 대한 요구를 예측해서 그랬던 것은 아니고 다음과 같은 규칙을 따르려고 해서였다.

 15. 어떤 종류든 게이트웨이 소프트웨어를 만들려고 한다면 데이터 스트림에 가능한 한 최소의 조작만 가하라. 그리고 수신자가 강제로 하게 하지 않는다면 정보를 ‘절대로’ 잘라 버리지 마라.

이 규칙을 따르지 않았다면 8비트 MIME 지원은 매우 어려웠을 것이고 많은 버그를 만들어 냈을 것이다. 규칙을 따랐기 때문에 내가 해야 할 일은 [RFC 1652](http://www.rfc-editor.org/info/rfc1652)를 읽고 헤더 생성 논리를 약간 수정하는 것뿐이었다.

유럽의 몇몇 사용자는 전화 네트워크의 비싼 비용을 조절할 수 있도록 한 세션에서 가져올 수 있는 메시지 수를 제한하는 옵션을 추가해달라고 요구해왔다. 나는 오랫동안 여기에 저항했고, 아직도 완전히 수긍하지 못했다. 하지만 세계를 상대로 프로그램을 만든다면 고객의 소리에 귀를 기울여야 한다. 그들이 돈을 내지 않는다고 해도 마찬가지다.

## 페치메일에서 배울 점

일반적인 소프트웨어 공학 주제로 돌아가기 전에 페치메일의 경험에서 배울 점이 몇 가지 더 있다. 기술적인 부분이 필요 없는 독자는 이 절을 건너뛰어도 된다.

rc 파일[^2-15] 구문은 선택 사항으로 ‘noise’라는 키워드를 포함하는데 이것은 구문 분석기`parser`에 의해 무시된다. rc 파일에서 허용하는 영어와 비슷한 구문은 잘라낼 것을 모두 잘라내고 얻은 전통적이고 간명한 키워드와 값의 쌍에 비해 훨씬 알아보기 쉽다.

[^2-15]: 역자주 일반적으로 프로그램이 실행될 때 참조하는 환경 설정이나 스크립트 파일을 말한다. RC는 Run Control, Run Command, Resource Configuration 등의 의미로 해석할 수 있다.

이것은 내가 rc 파일의 선언들이 명령형 소언어`imperative minilanguage`를 얼마나 많이 닮아가기 시작했는지 알아차린 뒤에 한 한밤중의 실험에서 시작됐다. (팝클라이언트의 ‘server’ 라는 키워드를 ‘poll’로 바꾼 이유도 이것이다.)

명령형 소언어를 보다 영어처럼 만들면 사용하기 더 쉬울 것처럼 보였다. 지금은 비록 이맥스나 HTML, 그리고 많은 데이터베이스 엔진에서 볼 수 있듯이 설계를 할 때 ‘언어처럼 만드는’ 파의 일원이긴 하지만 나는 ‘영어와 비슷한’ 구분을 두는 것에 대해 그다지 달가워하지 않는다.

전통적인 프로그래머들은 정확하고 짧으며 중복을 허용하지 않는 제어 구문을 선호하는 경향이 있다. 이것은 컴퓨팅 자원이 비싸서 구문 분석 단계가 최대한 싸고 간단해야 했을 때부터 내려온 문화적 유산이다. 영어는 대략 50% 정도 중복을 허용하므로 대단히 부적절한 모델로 보인다.

이것이 내가 영어와 비슷한 구문을 일반적으로 피하는 이유는 아니다. 이 문제를 언급한 이유는 그런 관습을 없애기 위해서다. CPU와 메모리 가격이 싸졌는데도 간명함은 저절로 없어지지 않았다. 최근에는 언어가 컴퓨터 관점에서 싼 가격이라는 점보다는 사람에게 편리한가 하는 점이 더 중요하다.

물론 조심해야 할 충분한 이유가 있다. 한 가지는 구문 분석 단계의 복잡성에 대한 비용이다. 구문 분석 단계를 버그가 우글거리면서 사용자로 하여금 그 자체만으로 혼란을 느끼게 만들고 싶지는 않을 것이다. 또 하나의 이유는 언어의 구문을 영어와 비슷하게 만들려고 노력하면 그 ‘영어’가 심각하게 왜곡돼 자연어와의 피상적인 유사점이 전통적인 구문만큼이나 혼란스럽게 되는 경우가 많다는 점이다. (소위 ‘4세대’ 언어와 상업용 데이터베이스 쿼리 언어에서 이런 경우를 자주 볼 수 있다.)

언어의 영역이 매우 제한돼 있기 때문에 페치메일 제어 구문에서는 이런 문제를 피하려고 했다. 일반적인 목적의 언어와는 거리가 멀었다. 언어가 표현하는 것이 별로 복잡하지 않았기 때문에 영어의 아주 작은 하위 집합에서 실제 제어 언어로 옮겨가는데 혼란을 일으킬 가능성이 적었다. 더 넓은 의미의 교훈을 여기에서 얻었다.

 16. 언어가 ‘튜링-완전`Turing-complete`’ 하지 않다면 구문상의 유연성이 필요하다.

또 하나의 교훈은 불투명함에 의한 보안이다. 페치메일 사용자 중에는 스누퍼`snooper` 가 우연히 비밀번호를 보지 못하도록 rc 파일에 있는 비밀번호를 암호화하자고 말하는 사람이 있었다.

나는 그 말을 받아들이지 않았는데, 그렇게 한다고 해서 보안이 강화되는 것이 아니기 때문이다. rc 파일의 읽기 권한을 얻은 사람이라면 사용자와 마찬가지로 페치메일을 실행시킬 수도 있다. 그리고 그들이 비밀번호를 원한다면 비밀번호를 얻기 위해 페치메일 코드에서 디코딩하는 코드를 뽑아낼 수도 있다.

.fetchmailrc의 비밀번호를 암호화했다면 사람들은 그리 심각하게 생각하지도 않고 보안에 대해 잘못된 관념을 갖게 됐을 것이다. 여기서 알 수 있는 일반적인 규칙은 다음과 같다.

 17. 보안 시스템은 그것이 보호하려는 비밀만큼만 안전하다. 가짜 비밀에 주의하라.

## 시장 방식 개발에 필요한 선행조건들

이 글을 초기에 검토해준 사람들과 시험적으로 청중이 됐던 사람들은 계속해서 성공적인 시장 방식 개발을 위한 선행 조건이 무엇인지 물었다. 여기에는 공동 개발자 공동체를 만들기 위해 프로젝트가 공개되는 시점에 지도자의 자질과 코드가 어떤 상태인지가 포함된다.

아예 처음부터 시장 방식으로 개발할 수 없다는 것은 자명하다. 테스트, 디버깅, 그리고 개선은 시장 방식으로 할 수 있다. 하지만 프로젝트를 시장 방식으로 시작하기는 매우 어렵다. 리누스는 그렇게 하지 않았다. 나도 마찬가지였다. 개발자 공동체는 초기에 실행하고 테스트할 수 있는 장난감이 필요하다.

공동체를 만들기 시작할 때 제시해야 하는 것은 그럴듯한 장래성이다. 프로그램이 특별히 잘 동작할 필요는 없다. 조잡하거나, 버그투성이여도 되고, 완성되지 않고 문서가 형편없어도 상관없다. 하지만 한 가지 확실하게 해야 할 것은 잠재적인 공동 개발자들에게 이것이 머지않은 미래에 정말 괜찮은 무언가로 진화할 수 있다는 것을 이해시키는 일이다.

리눅스와 페치메일 둘 다 강력하고 매력적인 기본 설계를 가지고 공개됐다. 내가 시장 모델에 대해 이야기하자 많은 사람이 이것을 중요하게 생각했고, 높은 수준의 설계에 대한 직관과 영리함이 프로젝트 지도자에게 필수적이라고 지레짐작으로 결론 내려 버렸다.

하지만 리누스는 그의 설계를 유닉스에서 따왔고, 나는 기본적으로 팝클라이언트에서 가져왔다. 물론 내 설계가 나중에 많이 바뀌긴 했지만, 리눅스는 훨씬 더 많이 바뀌었다. 그렇다면 시장 방식의 지도자`leader`나 조정자`coordinator`에게 정말 특별한 설계 재능이 필요한 것일까? 아니면 다른 사람이 가진 설계 재능을 이끌어 내는 것이 필요한 것일까?

나는 조정자가 특별하게 영리해서 독창적인 설계를 만들어낼 수 있는가는 중요하다고 생각하지 않는다. 하지만 조정자가 다른 사람의 좋은 설계를 알아볼 수 있는가는 절대적으로 중요하다고 생각한다.

리눅스와 페치메일 프로젝트는 이에 대한 증거를 보여준다. 리누스는 앞서 말했듯이 대단히 독창적인 설계자라고는 할 수 없으나 좋은 설계를 알아보는 대단한 요령을 보여주었고, 그것을 리눅스 커널에 통합해 넣었다. 앞서 페치메일에서 가장 강력한 설계 아이디어의 하나인 SMTP 포워딩은 다른 누군가에게서 온 것이라고 설명한 바 있다.

나는 설계의 독창성을 과소평가하는데, 이 글의 초기 청중들은 그건 내가 그런 독창성이 있기 때문에 당연하게 생각하는 것이라며 내게 경의를 표했다. 어느 정도는 사실이다. 분명히 코딩이나 디버깅보다 설계는 내가 가장 잘하는 일이다.

하지만 소프트웨어 설계에 있어 똑똑하고 독창적인 것의 문제는 그것이 버릇이 돼버린다는 점이다. 설계를 강력하고 단순하게 유지해야 할 때, 그렇게 하지 않고 계속해서 일을 멋지고 복잡하게 만들기 시작한다. 이전 프로젝트에서 나는 그런 성향 때문에 실패한 적이 있었고, 페치메일에서는 간신히 그것을 이겨냈다.

그래서 페치메일이 성공할 수 있었던 것은 부분적으로 내가 똑똑해지려는 유혹을 이겨냈기 때문이라고 생각한다. 이것은 성공적인 시장 프로젝트에는 설계의 독창성이 필수라는 것에 대한 (최소한) 반대되는 주장이다. 리눅스를 생각해 보자. 리누스 토르발스가 개발 도중 운영체제 설계에서 근본적인 혁신을 이끌어 내려고 노력했다고 가정해 보자. 그 결과로 만들어진 커널이 지금 있는 것처럼 안정적이고 성공적일지 생각이나 할 수 있을까?

어느 정도 기본적인 수준의 설계와 코딩 기술은 물론 필요하지만, 시장 방식 프로젝트를 시작하려고 심각하게 생각하는 사람이라면 그런 정도는 적어도 넘어섰으리라고 기대하는 것이다. 오픈소스 공동체의 내부 시장은 평판에 대한 미묘한 압력을 사람들에게 가한다. 그래서 지속적으로 따라갈 경쟁력이 없는 사람은 개발 프로젝트를 시작하지 않게 된다. 이것은 지금까지 잘 들어맞았던 것 같다.

시장 방식 프로젝트에서 똑똑한 설계만큼이나 중요하다고 생각하는 것이지만, 일반적으로 소프트웨어 개발과는 연관 짓지 않는 또 한 종류의 기술이 있다. 어쩌면 더 중요할지도 모른다. 시장 방식 프로젝트를 조정하거나 이끄는 사람은 사람들과 의사소통을 잘하는 기술이 있어야 한다.

이것은 명확하다. 개발자 공동체를 만들려면 사람들을 끌어 모아야 하고, 그들에게 흥미를 주어야 하고 그들이 한 일의 결과에 대해 기분 좋도록 만들어 주어야 한다.  기술적인 논란은 이런 것을 이룩하는 데 도움이 많이 되긴 하지만 그것이 전부는 아니다. 성격도 크게 작용한다.

리누스가 괜찮은 녀석이고 다른 사람들이 그를 좋아하고, 그를 도와주고 싶어한다는 것은 우연이 아니다. 내가 정력적이고 외향적이며 많은 사람과 일하는 것을 즐기고 만화 속 인물과 비슷한 인상을 주는 것은 우연이 아니다. 시장 모델이 성공하게 만들려면 사람을 끄는 매력이 조금이라도 있는 것이 매우 큰 도움이 된다.

## 오픈소스 소프트웨어의 사회적 문맥

다음과 같은 말이 있다. 가장 뛰어난 해킹은 해커의 일상적인 문제를 푸는 개인적인 해결책부터 시작된다. 그리고 그 문제가 많은 사용자들에게 전형적이라는 것이 밝혀지면 널리 퍼지게 된다. 첫 번째 법칙으로 되돌아와 더 유용한 방식으로 다시 말해보자.

 18. 재미있는 문제를 풀어보고 싶다면, 자신에게 재미있는 문제를 찾아 나서는 것부터 시작하라.

칼 해리스와 팝클라이언트가 그랬고, 나와 페치메일이 그랬다. 이 말은 오래 전부터 이해되어 왔다. 재미있는 점은 리눅스와 페치메일의 역사가 보여준 것처럼 그 다음 단계에 있다. 사용자와 공동 개발자가 이루는 크고 활동적인 공동체의 눈앞에서 소프트웨어가 진화해 가는 것이다.

『맨먼스 미신』에서 프레더릭 브룩스는 프로그래머의 시간은 다른 것으로 대체될 수 없다고 말했다. 지연되는 소프트웨어 프로젝트에 개발자를 더 투입하는 것은 완료 시기를 더 늦출 뿐이다.[^2-16] 그는 프로젝트에서 복잡성과 의사소통에 드는 비용이 개발자 수의 제곱에 비례하는 반면 할 수 있는 일의 양은 개발 수에 비례한다고 주장했다.[^2-17] 이 주장은 그때부터 ‘브룩스의 법칙’으로 알려졌고 널리 자명한 이치로 간주됐다. 하지만 브룩스의 법칙이 전부라면 리눅스는 불가능했을 것이다.

[^2-16]: 역자주 「일정이 늦어진 소프트웨어 프로젝트에 인력을 추가하는 것은 일정을 더욱 늦추는 결과를 낳을 뿐이다.(한국어 번역판 48페이지)」

[^2-17]: 역자주 「커뮤니케이션 때문에 추가되는 부담은 훈련과 상호 커뮤니케이션의 두 부분으로 구성된다. 모든 작업자가 기술, 작업 목표, 전반적인 전략 그리고 작업 계획에 대하여 훈련 받아야 한다. 이 훈련은 분할할 수 없다. 그러므로 여기에 추가되는 노력은 작업자의 수에 비례한다. 상호 커뮤니케이션은 문제가 더욱 심각하다. 업무의 각 부분을 분리하여 관리한다면 거기에 들어가는 노력은 n(n-1)/2 만큼 증가한다. 작업자가 셋이 되면 둘일 때보다 세 배 만큼 커뮤니케이션이 필요하다. 넷이 되면 둘일 때보다 여섯 배 만큼 커뮤니케이션이 이뤄져야 한다. 더욱이 작업자들이 함께 해결할 문제가 있어서 셋이나 넷이 회합이라도 가져야 한다면 상황은 더욱 나빠지게 된다. 커뮤니케이션 때문에 추가되는 노력은 원래 임무를 분할한 효과를 상쇄한 상황을 가져온다. 소프트웨어 구축작업은 내재적으로 시스템적인 노력, 즉 복잡한 상호관계의 실행이기 때문에 커뮤니케이션 노력이 많이 필요하며, 이는 분할에 의하여 줄어든 개별적인 작업시간을 순식간에 잡아먹게 된다. 그래서 인력을 추가하면 일정이 단축되기보다는 오히려 연장되는 것이다.(한국어 번역판 38∼39페이지)」

나중에 제럴드 와인버그`Gerald Weinberg`의 고전인 『프로그래밍 심리학』[^2-18]에서 브룩스의 말에 대한 중요한 수정 사항이 제시됐다는 것을 알았다. ‘자아를 내세우지 않는 프로그래밍`egoless programming`’에 대한 논의에서 와인버그는 개발자들이 자신의 코드에 텃세를 부리지 않고 다른 사람으로 하여금 버그를 찾고 개선 가능성을 찾아내도록 격려하는 곳에서는 다른 어느 곳에서보다 극적으로 빠른 개선이 일어난다고 이야기했다.

[^2-18]: 역자주 『The Psychology of Computer Programming: Silver Anniversary Edition, Gerald M. Weinberg, Dorset House, 1998, ISBN: 9780932633422』, 『프로그래밍 심리학, 조상민 옮김, 인사이트, 2008년, ISBN: 9788991268364』

아마도 와인버그의 분석이 적절한 평가를 받지 못한 이유는 용어 선택 때문이었을 것이다. 인터넷의 해커들이 ‘자아를 내세우지 않는다’고 묘사하는 것에는 웃음 지을 수밖에 없다.[^2-19] 하지만 나는 그의 주장이 지금 그 어느 때보다 절실하다고 생각한다.

[^2-19]: 역자주 ‘자아를 내세우지 않는 프로그래밍’이란 소스 공개와 동료검토를 전제해서 다른 사람이 쉽게 읽고 이해할 수 있게 최대한 자기중심적이지 않게 코드를 쓰는 것을 말한다. 이 책의 한국어 번역판에서는 이를 ‘비자아적 프로그래밍’이라고 옮겼다.

유닉스의 역사는 우리가 리눅스로부터 배우고 있는 것을, 그리고 내가 실험적으로 더 작은 규모로 리누스의 방법을 따라 함으로써 검증한 것을 미리 준비해 두었어야 했다. 다시 말해 코딩은 본질적으로 고독한 작업인데 비해 정말 중요한 해킹은 전체 공동체의 주의와 지력`brainpower`을 이용함으로써 이루어진다는 것이다. 폐쇄 프로젝트에서 자신의 두뇌만을 사용하는 개발자는 수백 명의 사람이 버그를 찾아내고 개선을 이루어내는 열려 있는 진화적 환경을 어떻게 만들어 내는지 아는 개발자에 비해 뒤떨어지기 마련이다.

하지만 전통적 유닉스 세계에는 이런 접근 방법을 끝까지 밀어 붙이지 못하는 요인이 몇 가지 있었다. 첫 번째는 다양한 이용허락의 법적인 제약, 영업비밀, 그리고 상업적인 이해 관계였다. 또 하나는 나중에야 알게 됐지만 인터넷이 그리 훌륭하지 못했기 때문이다.

싼 가격에 인터넷을 이용할 수 있게 되기 전에는 지리적으로 좁은 지역에 공동체가 자리잡고 있었고, 그 공동체 문화에는 와인버그의 ‘자아를 내세우지 않는’ 프로그래밍이 장려됐으며 개발자들은 쉽게 많은 사람들, 즉 숙련된 훈수꾼과 공동 개발자를 끌어들일 수 있었다. 벨 연구소, MIT 인공지능연구소, UC 버클리 같은 곳이 바로 전설적인 혁신이 일어난 곳이고 여전히 그런 잠재력을 지닌 곳이다.

리눅스는 재능을 끌어올 풀`pool`로 전세계를 사용하기 위해 의식적으로, 또 성공적으로 노력한 최초의 프로젝트였다. 나는 리눅스의 태동기가 월드 와이드 웹의 탄생과 일치하는 것을, 그리고 리눅스가 유아기를 벗어나던 1993∼1994년 경에 ISP 산업과 인터넷에 주류의 관심이 폭발하기 시작했던 것을 우연이라고 생각하지 않는다. 리누스는 급속히 보급된 인터넷을 가능하게 했던 그 규칙에 따라 어떻게 일을 진행해야 하는지 알았던 최초의 사람이다.

저렴하게 인터넷을 사용할 수 있었던 것이 리눅스 모델이 진화하는데 필수적인 조건이기 했지만 그것이 충분조건이라고 생각하지는 않는다. 또 하나의 중요한 요소는 리더십 방식과 협력하는 관습의 발전인데, 이것이 개발자로 하여금 공동 개발자를 끌어 모으고 매체를 최대한 활용하게 했던 것이다.

그렇다면 리더십 방식이란 무엇이고 이런 관습이란 어떤 것인가? 권력관계에 기반한 것은 분명 아니다. 만일 그런 것에 기반했다면 강제에 의한 리더십은 우리가 보는 것과 같은 결과를 내지 못했을 것이다. 와인버그는 19세기 러시아 무정부주의자 표트르 알렉세예비치 크로포트킨`Pyotr Alekseyevich Kropotkin`, 1842~1921의 『크로포트킨 자서전』[^2-20]에서 다음과 같은 구절을 인용한다.

[^2-20]: 역자주 『Memoirs of a Revolutionist, Peter Kropotkin, Dover Publications, 2010, ISBN: 9780486473161』, 『크로포트킨 자서전, P. A. 크로포트킨, 김유곤 옮김, 우물이있는집, 2003년, ISBN: 9788989824145』. <https://archive.org/details/memoirsofrevolut00krop>에서 영문판 전자책을 참고할 수 있다.

「농노를 소유한 가정에서 컸기 때문에 나는 내 시대 모든 젊은이들처럼 능동적인 생활을 했다. 명령하고, 지시하고, 꾸중하고, 벌주는 그런 일에 대한 필요성을 크게 확신했다. 하지만 내가 큰 사업을 경영해야 했을 때는 자유인들과 거래해야 했고 단 한 번의 실수로 심각한 결과가 나타나게 됐을 때 명령과 훈육의 원리에 기반해 행동하는 것과 공동 이해의 원리에 의해 행동하는 것 사이의 차이점을 높이 평가하기 시작했다. 군대에서라면 전자에 따라 일하는 것이 훨씬 낫겠지만, 실생활에서 많은 사람의 의지를 수렴해서 노력해야만 이룰 수 있는 목표를 겨냥했을 때는 별 가치가 없다.」

‘많은 사람의 의지를 수렴해 노력하는 것’이 바로 리눅스와 같은 프로젝트가 요구하는 것이다. 그리고 ‘명령의 원리’는 결과적으로 우리가 인터넷이라고 부르는 무정부주의자들의 천국에 사는 자원봉사자에게 적용하기 불가능한 것이다. 효과적으로 일하고 경쟁하기 위해 공동 프로젝트를 이끌어 보고 싶은 해커들은 크로포트킨의 ‘이해의 원리’가 어렴풋이 제시하는 방식에 따라 같은 관심을 가진 공동체를 어떻게 효과적으로 끌어 모으고 격려할 것인지 배워야 한다.

앞에서 나는 리누스의 법칙을 설명하려고 ‘델파이 효과’를 언급했다. 하지만 생물학과 경제학에서의 적응계에 비유하는 것이 더 강력한 비유라고 할 수 있다. 리눅스 세계는 많은 점에서 생태계나 자유 시장과 같이 행동한다. 일단의 이기적 에이전트들이 효용을 극대화하려고 애쓰는 과정을 통해 스스로를 수정하는 자율적인 질서를 만들어내며, 이것은 중앙 통제가 이룰 수 있는 어떤 결과보다 더 정교하고 효율적이다. 그렇다면 여기에서 ‘이해의 원리’를 찾아낼 수 있다.

리눅스 해커들이 최대화하려는 ‘효용 함수’는 고전적 의미에서의 경제적인 것이 아니라 그들 자신의 측정할 수 없는 자아 만족과 다른 해커들 사이의 평판이다. 이런 동기를 ‘이타적’이라고 말할 지도 모르겠지만 그렇게 말하는 것은 이타주의 그 자체가 이타주의자의 자아를 만족시키는 한 형태라는 사실을 무시하는 것이다. 이런 방식으로 일을 처리하는 자발적 문화는 사실 그렇게 찾아보기 힘든 것은 아니다. 내가 오랫동안 참여해왔던 또 하나의 문화는 공상과학 소설 팬들의 세계다.[^2-21] 해커들의 세계와 다르지 않게 여기에서는 다른 팬들 사이에서 자신의 평판이 높아지는 ‘자아 상승’이 자발적인 활동 뒤의 기본적인 동기라고 분명하게 인식한다.

[^2-21]: 역자주 [GT(General Technics)](http://www.mystery.com/gt/) 모임 등을 말한다.

리누스는 대부분 다른 사람들에 의해 개발이 이루어지는 프로젝트의 문지기`gatekeeper`로 자신을 위치시키는데 성공했고, 프로젝트가 스스로 유지될 수 있기까지 계속해서 흥미거리를 공급해 줌으로써 크로포트킨의 ‘공유 이해의 원리’의 의미를 정확하게 따랐다. 준 경제학적인 관점에서 리눅스 세계를 보면 어떻게 이해가 적용됐는지를 알 수 있다.

리누스의 방법을 ‘자아 상승’에 있어서 효과적인 시장을 만드는 길로 볼 수 있다. 개개인인 해커들의 이기심을 지속적인 협동으로만 이룩할 수 있는 어려운 목적과 최대한 단단하게 연결시키는 것이다. 페치메일 프로젝트에서 나는 더 작은 규모였지만 이 방법을 그대로 따라 했고 좋은 결과를 냈다. 아마도 내가 리누스보다 더 의식적이고 체계적으로 일을 해냈을 것이다.

많은 사람들, 특히 자유 시장을 정치적으로 믿지 않는 사람들은 스스로에게 방향이 맞추어진 이기주의자들의 문화가 파편화돼 있으며 텃세가 심하고 소모적이면서, 비밀이 많고 적대적일 것이라고 생각한다. 하지만 하나만 예로 들자면 이런 기대는 리눅스 문서의 놀랄만한 다양성과 질, 깊이에 의해 산산이 부서지고 만다. 프로그래머들이 문서 작업을 끔직하게 싫어한다는 것은 모두가 기정 사실로 받아들이고 있다. 그렇다면 대체 리눅스 해커들이 문서를 그렇게 많이 만들어냈다는 것을 어떻게 설명할 것인가? 분명히 리눅스의 자아 상승을 위한 자유 시장은 막대한 자금이 들어간 상업용 소프트웨어 제작자들의 문서 작업보다 다른 사람을 위한 고결한 행동을 더 잘 해낸 것이다.

페치메일과 리눅스 커널 프로젝트는 둘 다 많은 해커들의 자아를 적절히 보상해 줌으로써 강력한 개발자와 조정자가 인터넷을 이용해 많은 수의 공동 개발자를 가지는 이익을 얻으면서 프로젝트가 혼란스럽게 스스로 붕괴하는 것을 막을 수 있다는 것을 보여준다. 브룩스의 법칙에 대해서 나는 다음과 같은 반대 제안을 한다.

 19. 개발 조정자가 최소한 인터넷만큼 좋은 매체를 갖고 있으며 강제력을 사용하지 않고 어떻게 이끌어야 할 지 알고 있다면, 한 명 보다는 여러 명의 지도자가 필연적으로 더 낫다.

미래의 오픈소스 소프트웨어는 점점 리누스의 게임을 어떻게 해야 하는지 아는 사람들, 성당을 뒤로 하고 시장을 끌어안을 수 있는 사람들에게 속할 것이라고 생각한다. 개인의 비전과 똑똑함이 문제가 되지 않으리라는 말이라기보다는 오픈소스 소프트웨어의 최첨단은 개인의 비전과 똑똑함에서 시작해 자발적으로 흥미를 보이는 공동체를 효과적으로 구축해서 그것을 증폭시키는 사람들에게 속할 것이라는 뜻이다.

그리고 그것은 오픈소스 소프트웨어의 미래에만 국한되지는 않을 것이다. 폐쇄소스로 개발하는 사람은 리눅스 공동체가 문제를 해결하기 위해 끌어낼 수 있는 재능의 풀과 경쟁할 수 없다. 극소수만이 페치메일에 공헌했던 200명보다 많은 사람을 고용할 수 있을 것이다. (1999년에는 600명, 2000년에는 800명이 됐다.)

아마 최종적으로는 협동이 더 도덕적이라거나 ‘소프트웨어 매점`software hoarding`’[^2-22]이 덜 도덕적이라서가 아니라 단지 폐쇄소스 측과 오픈소스 공동체와의 군비 경쟁에서 오픈소스 측이 한 문제에 훨씬 큰 비율로 숙련된 사람의 시간을 쏟을 수 있기 때문에 오픈소스 문화가 승리를 거둘 것이라는 얘기다.

[^2-22]: 역자주 자유 재배포와 수정을 금지하는 이용허락이나 영업비밀을 이용해 소프트웨어에 대한 소유권을 유지하려는 행위를, 주로 자유 소프트웨어 재단과 GNU 프로젝트에서 경멸적으로 표현하는 말이다. 공동체에서 자유롭게 가져간 소스를 개선한 뒤에 개선점을 공동체로 다시 되돌려주지 않고 자신만 이용하는 기업의 행위도 여기에 포함되기 때문에 선전적으로 ‘소프트웨어 약탈’로 표현할 수 있다.

## 후기: 네트스케이프가 시장 스타일을 받아들이다!

역사가 만들어지는 데 일조했다는 사실을 깨닫는 것은 좀 이상한 느낌이다.

1998년 1월 22일, 내가 처음으로 이 글을 발표한 지 7달 정도 지난 시점에서 네트스케이프가 ‘[네트스케이프 커뮤니케이터의 소스를 공개한다고 발표](https://web.archive.org/web/19980202132717/http:/www.netscape.com/newsref/pr/newsrelease558.html)’했다.

나는 발표가 있기 전날까지도 이런 일이 일어나리라고는 생각하지 못했다. 네트스케이프의 최고기술책임자`CTO: Chief Technology Officer`이자 부사장인 에릭 한`Eric Hahn`은 발표 직후 다음과 같은 이메일을 내게 보냈다. “네트스케이프 임직원 모두를 대신해 우리가 이곳까지 오도록 도와주신 것에 감사드립니다. 당신의 생각과 글이 우리의 결정에 근본적인 영감을 주었습니다.”

그 다음 주인 1998년 2월 4일에 나는 네트스케이프의 초청으로 실리콘밸리에 가서 고위 경영진 및 기술진과 함께 하루짜리 전략 회의에 참석했다. 우리는 네트스케이프의 소스 공개 전략과 이용허락을 함께 설계했고 최종적으로는 오픈소스 공동체에 크고 긍정적인 영향을 끼칠 것으로 희망하는 몇몇 계획을 만들었다.

며칠 뒤에 나는 다음과 같이 썼다.

  「네트스케이프는 시장 모델을 상업계에서 대규모로 실제 테스트할 수 있는 기회를 제공하려 한다. 오픈소스 문화는 이제 위험을 맞이하게 된 것이다. 네트스케이프의 시도가 실패한다면 오픈소스 개념은 불신을 받을 것이고 상업계에서 향후 십 년 간은 오픈소스를 다시 받아들이려 하지 않을 것이다.

  반면에 볼만한 기회가 될 수도 있다. 월 스트리트 등의 첫 반응은 조심스럽지만 긍정적이었다. 우리 자신을 증명할 기회를 얻은 것이다. 만일 네트스케이프가 이번 행보로 상당한 양의 시장 점유율을 끌어올린다면 컴퓨터 산업에서 오래 전에 이루어져야 했던 혁명을 시작하게 되는 것이다.

  다음 한 해는 매우 교육적이며 재미있는 한 해가 될 것이다.」

그리고 실제로 그랬다. 이 글을 쓰고 있는 2000년 중반 현재, 뒤에 모질라`Mozilla`로 이름 붙여진 것의 개발이 제한적인 성공을 거두고 있다. 모질라는 마이크로소프트의 브라우저 시장 독점을 부정하려던 네트스케이프의 원래 목표를 달성했다. 또한 몇몇 극적인 성공, 특히 차세대 게코`Gecko` 레이아웃 엔진의 출시도 이루어 냈다.

그러나 네트스케이프 외부에서 대규모 개발 노력을 끌어오려던 모질라 설립자들의 원래 희망은 아직 이루지 못하고 있다. 문제는 시장 모델의 한 가지 기본 규칙을 실제로 깨뜨린 오랫동안 이루어져 왔던 모질라 배포 방식에 있는 것 같다. 모질라는 (사유 모티프 라이브러리에 대한 이용허락이 필요한 소스에서 빌드되기 때문에 릴리스 후 1년이 지날 때까지는) 잠재적 기여자들이 쉽게 실행하고 작동하는 것을 볼 수 있는 기능이 함께 제공되지 않는다.

(외부 세계의 관점에서 볼 때) 대부분 부정적인 것이지만, 모질라 모임은 프로젝트가 출범한지 2년 반이 지나도록 제품으로 쓸 수 있을 만한 수준의 브라우저를 내놓지 못하고 있다. 또한 1999년에는 프로젝트의 주요 인물 중 한 명인 제이미 저윈스키`Jamie Zawinski`가 회사의 관리 부실과 놓쳐버린 기회를 불평하며 회사를 그만두어 파문을 일으켰다. 그가 올바르게 지적한 말은 ‘오픈소스는 대단하다. 그러나 마법의 가루는 아니다’였다.[^2-23]

[^2-23]: 역자주 <http://www.jwz.org/gruntle/nomo.html> 참고.

실제로 그렇다. 모질라에 대한 장기적 예측은 제이미 저윈스키가 퇴사 편지를 남긴 때에 비해 (2000년 11월) 현재 극적으로 나아진 듯 보인다. 지난 몇 주 동안 모질라의 매일 밤 릴리스`nightly release`[^2-24]는 제품 수준으로 쓸 수 있는 임계치를 마침내 통과했다. 그러나 제이미는 오픈소스로 간다고 해서 잘못 정의된 목표나 엉망으로 꼬여있는 코드, 그리고 다른 종류의 소프트웨어 엔지니어들이 가진 만성적인 병폐를 반드시 구해주는 것은 아니라고 올바르게 지적했다. 모질라는 오프소스가 어떻게 성공할 수 있고 또한 어떻게 몰락할 수 있는 지를 동시에 보여주었다.

[^2-24]: 역자주 안정(stable) 판 외에 매일 밤 빌드되는 테스트 판을 말한다. <https://nightly.mozilla.org/>

그러나 그러는 동안, 오픈소스 아이디어는 성공을 계속했고 어디서나 후원자를 찾아볼 수 있게 됐다. 네트스케이프가 공개된 이후부터 우리는 오픈소스 개발 모델에 대한 엄청나게 폭발적인 관심을 보아 왔다. 이러한 경향은 리눅스 운영체제의 성공으로 인해 강해졌으며 동시에 지속적인 성공을 이끌고 있다. 모질라가 촉발한 추세는 보다 가속된 속도로 계속될 것이다.

## 읽어볼 만한 글들

프레더릭 브룩스의 고전 『맨먼스 미신』에서 몇몇 부분을 인용했다. 앞으로도 여러 관점에서 그의 통찰력을 발전시킬 수 있을 것이다. 애디슨-웨슬리의 25주년 기념판 『The Mythical Man-Month, Frederick Brooks, Addison-Wesley, Anniversary Edition, 1995, ISBN: 9780201835953』(『맨먼스 미신, 프레더릭 브룩스, 김성수 옮김, 케이앤피, 2007년, ISBN: 9788995982204』)을 추천한다. 여기에는 그가 1986년에 쓴 글 「은총알은 없다」가 들어있다. 새 기념판은 매우 귀중한 20년 후의 회고를 담고 있다. 브룩스는 여기서 원문의 몇몇 판단이 시간이 흐름에 따라 옳지 않은 것으로 드러났다고 솔직하게 인정하고 있다. 나는 이 글을 대략 마무리 지은 후에 회고담을 읽어보았는데, 브룩스가 시장 방식을 마이크로소프트에서 연유한 관습으로 생각한다는 것을 발견하고 깜짝 놀랐다!

제럴드 와인버그의 『The Psychology of Computer Programming: Silver Anniversary Edition, Gerald M. Weinberg, Dorset House, 1998, ISBN: 9780932633422』 (『프로그래밍 심리학, 조상민 옮김, 인사이트, 2008년, ISBN: 9788991268364』)은 비운의 개념인 ‘자아를 내세우지 않는 프로그래밍(비자아적 프로그래밍)’을 소개했다. ‘명령의 원칙’이 무용지물이라는 것을 처음으로 깨달은 사람이 와인버그는 아니지만 그는 아마도 처음으로 그것을 인식하고 특별히 소프트웨어 개발과 관련지어 논지를 전개시킨 첫 번째 사람일 것이다.

리처드 게이브리얼`Richard P. Gabriel`은 리눅스 이전 시대의 유닉스 문화에 대해 숙고하고 주저하면서도 원시적인 시장 방식 모델이 우월하다는 것을 1989년의 글인 「리스프: 좋은 소식과 나쁜 소식, 그리고 큰 성공을 거두는 방법`Lisp: Good News, Bad News, and How To Win Big`」에서 밝혔다. 몇 가지 시대에 뒤떨어진 감은 있지만 이 글은 여전히 나를 포함한 리스프 팬들에게 적절한 찬사를 받고 있다. 편지를 교환하던 사람 중 한 명이 나에게 ‘나쁜 것이 좋은 것이다’라는 제목을 가진 절이 리눅스를 예견하다시피 했다는 것을 상기시켜 주었다. 이 글은 <http://www.naggum.no/worse-is-better.html>에서 참고할 수 있다.

드마르코와 리스터의 『Peopleware: Productive Projects and Teams, De Marco and Lister, Dorset House, 1987, ISBN: 0932633056』(『피플웨어: 정말로 일하고 싶어지는 직장 만들기, 톰 디마르코 외, 박승범 옮김, 매일경제신문사, 2003년, ISBN: 9788974422493』)은 결코 평가절하될 수 없는 보석이다. 프레더릭 브룩스가 회고의 글에서 이 책을 인용해서 기뻤다. 저자가 말하고 있는 것 중에서 리눅스나 오픈소스 공동체에 바로 적용될 수 있는 것은 거의 없지만 창조적인 작업의 필요조건에 대한 통찰력은 날카롭고, 시장 모델의 미덕을 상업적인 문맥에 결합시키려고 하는 사람에게는 가치 있는 것이다.

마지막으로, 사실 나는 이 글을 「성당과 광장`The Cathedral and the Agora`」이라고 이름붙이려고 했다. 광장은 그리스어로 열린 시장이나 공개 집회장을 뜻한다. 마크 밀러`Mark Miller`와 에릭 드렉슬러`Eric Drexler`의 생산적인 글, ‘광장 시스템’에 대한 논문들은 계량 생태학과 비슷한 시장의 속성들을 묘사함으로써 5년 뒤에 리눅스를 알게되었을 때 오픈소스 문화에서 일어나는 현상들을 그에 비유해 생각할 수 있게 도와주었다. 이 글들은 <https://web.archive.org/web/19980206062445/http://www.agorics.com/agorpapers.html>에서 구할 수 있다.

## 감사의 글

이 글은 많은 사람들과의 대화를 통해 잘못을 수정하는데 도움을 받았다.

특별히 제프리 덧키`Jeffrey Dutky, dutky@wam.umd.edu`에게 감사한다. 그는 ‘디버깅은 병렬 처리가 가능하다’는 말을 제안해 주었고 그로부터 이어지는 분석을 발전시키는데 도움을 주었다. 낸시 레보비츠`Nancy Lebovitz, nancyl@universe.digex.net`에게도 감사한다. 그녀는 크로포트킨을 인용해 내가 와인버그를 흉내 내도록 도와주었다. GT`General Technics` 모임의 조앤 에슬린저`Joan Eslinger, wombat@kilimanjaro.engr.sgi.com`와 마르티 프란츠`Marty Franz, marty@net-link.net`도 예리한 비판을 보내주었다. 이 글의 첫 공개 판의 첫 번째 시험적인 청중이 되어준 필라델피아 리눅스 사용자 모임`PLUG: Philadelphia Linux User's Group` 회원들에게 감사한다.

마지막으로 리누스 토르발스의 논평이 도움이 되었으며 초기에 그가 해준 추천은 매우 격려가 되는 것이었다.

---

![](figures/sagrada-03.jpg "")

사그라다 파밀리아 성당, 나선형 계단[^2-25]

[^2-25]: 역자주 Copyright 2006 Sagrada Família. 이 이미지는 크리에이티브 커먼즈 <[저작자표시-동일조건변경 허락 3.0 카탈루냐 이용허락][link-sagrada-03]>에 따라 이용할 수 있다.

[link-sagrada-03]: http://commons.wikimedia.org/wiki/File:Sagrada_Fam%C3%ADlia._Torres_(escales_helico%C3%AFdals).jpg

방어 시스템은 보호해야 할 사람이나 재산을 한 장소에 모아 놓는 것이 광대한 대지에 분산되어 있는 것보다 훨씬 편리하겠다는 생각에서 시작되었다. 이것은 (분산과 세분을 활용하는 게릴라의 전술과는 반대인) 중앙 집중 개념으로, 보호하고 방어해야 할 것을 위해 아주 정확하게 경계 긋고 담을 치는 것이다.
— 에블린 페레 크리스탱(Evelyne Pere-Christin), 『벽, 눌와, 2005년, 93페이지』

